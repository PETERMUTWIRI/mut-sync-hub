'use server';
import { InferenceClient } from '@huggingface/inference';
import { prisma } from '@/lib/prisma';
import emailjs from '@emailjs/browser';
import { google } from 'googleapis';
import { format } from 'date-fns';

/* ---------- env ---------- */
const hf = new InferenceClient(process.env.HF_TOKEN);          // free
const calendar = google.calendar({ version: 'v3', auth: new google.auth.GoogleAuth({
  keyFile: process.env.GOOGLE_APPLICATION_CREDENTIALS,                    // ./google-sa.json
  scopes: ['https://www.googleapis.com/auth/calendar.events'],
}) });

/* ---------- Types ---------- */
export interface AgentMessage {
  role: 'user' | 'assistant';
  content: string;
}

/* ---------- Server Actions ---------- */

/** 1.  Text / voice chat (anonymous) */
export async function agentChat(message: string, threadId = 'anon'): Promise<AgentMessage> {
  const history = await getThread(threadId);
  const prompt = buildPrompt(message, history);
  const reply = await hf.chatCompletion({
    model: 'microsoft/DialoGPT-medium',
    messages: [{ role: 'user', content: prompt }],
  });
  const out: AgentMessage = { role: 'assistant', content: reply.choices[0]?.message?.content?.trim() || '' };
  await saveMessage(threadId, 'user', message);
  await saveMessage(threadId, 'assistant', out.content);
  return out;
}

/** 2.  Brain-storm requirements (returns next question) */
export async function gatherRequirements(service: string, threadId = 'anon') {
  const history = await getThread(threadId);
  const prompt = `User wants "${service}". Ask ONE concise question to clarify requirements. Reply JSON only: {"question":"...","complete":boolean}`;
  const raw = await hf.textGeneration({ model: 'google/flan-t5-large', inputs: prompt, parameters: { max_new_tokens: 120, temperature: 0.7 } });
  try { return JSON.parse(raw.generated_text); } catch { return { question: 'Could you tell me more about your goals?', complete: false }; }
}

/** 3.  Book calendar slot + email summary */
export async function bookSlot(date: string, time: string, email: string, threadId = 'anon') {
  const event = {
    summary: 'MutSyncHub Consultation',
    description: `Thread: ${threadId}`,
    start: { dateTime: `${date}T${time}:00`, timeZone: 'Africa/Nairobi' },
    end: { dateTime: `${date}T${String(Number(time.split(':')[0]) + 1).padStart(2, '0')}:00:00`, timeZone: 'Africa/Nairobi' },
    attendees: [{ email }],
  };
  await calendar.events.insert({ calendarId: 'primary', requestBody: event });
  await emailSummary(threadId, email);
  return { ok: true };
}

/** 4.  Hover-tooltip explanation */
export async function explainStat(statName: string, value: number) {
  const prompt = `Explain this metric in one short sentence for a non-technical user: "${statName}" = ${value}.`;
  const res = await hf.textGeneration({ model: 'google/flan-t5-large', inputs: prompt, parameters: { max_new_tokens: 60 } });
  return res.generated_text;
}

/** 5.  Read live analytics + visual suggestion */
export async function analyticsQuery(question: string, threadId = 'anon') {
  /* dummy example â€” replace with real /api/analytics call */
  const data = { activeUsers: 142, revenue: 133700, labels: ['Mon', 'Tue', 'Wed'], values: [40, 55, 45] };
  const visual = pickVisual(question, data);
  const answer = await agentChat(`Answer this business question using the data: ${JSON.stringify(data)}. Question: ${question}`, threadId);
  return { answer, visual };
}

/* ---------- helpers ---------- */
async function getThread(id: string) {
  return await prisma.agentMessage.findMany({ where: { threadId: id }, orderBy: { createdAt: 'asc' } });
}
async function saveMessage(id: string, role: string, content: string) {
  await prisma.agentMessage.create({ data: { threadId: id, role, content } });
}
function buildPrompt(msg: string, hist: any[]) {
  return hist.map((h: any) => `${h.role}: ${h.content}`).join('\n') + `\nuser: ${msg}\nassistant:`;
}
function pickVisual(q: string, data: any) {
  if (/trend|over time/i.test(q)) return { type: 'line', data };
  if (/distribution|share/i.test(q)) return { type: 'pie', data };
  return { type: 'bar', data };
}

async function emailSummary(threadId: string, email: string) {
  const msgs = await getThread(threadId);
  const summary = msgs.map((m: any) => `${m.role}: ${m.content}`).join('\n');
  await emailjs.send(
    process.env.EMAILJS_SERVICE_ID!,
    process.env.EMAILJS_TEMPLATE_ID!,
    { thread_id: threadId, email, summary },
    process.env.EMAILJS_PUBLIC_KEY!
  );
}

/* ---------- HOT 2025 / 26 SERVICES ---------- */
const HOT_SERVICES = [
  "AI-Agent-Ecosystems",
  "Quantum-Safe-Crypto-Stack",
  "Edge-AI-for-IoT",
  "Synthetic-Data-Generator",
  "Voice-Cloning-Defense",
  "Serverless-LLM-Runtime",
  "Green-Cloud-Optimizer",
  "Real-time-Fraud-Graph",
  "Privacy-Preserving-Analytics",
  "Autonomous-Supply-Chain"
];

export async function getHotServices() { return HOT_SERVICES; }

/* ---------- full solution-aware prompt ---------- */
function buildSolutionPrompt(userMsg: string, history: any[], solutions: any[]) {
  const catalog = solutions.map((s: any) => `- ${s.title}: ${s.description}`).join('\n');
  return `You are MutSyncHub's AI solutions expert.
Catalog:
${catalog}

Hot 2025 services: ${HOT_SERVICES.join(', ')}

Conversation so far:
${history.map((h: any) => `${h.role}: ${h.content}`).join('\n')}

User: ${userMsg}
Ask 1 clarifying question at a time until you know:
1. Business size (startup/SME/enterprise)
2. Main pain-point
3. Budget range (KES 50k/200k/1M+)
4. Timeline (weeks/months)
Reply JSON: {question:"...",complete:false,serviceSuggestion:"id from catalog OR hot service",calendarOffer:true}
`;
}
